#!/usr/bin/env node

//        _         __ _
//  _   _| |_      / _| |_   ___  __
// | | | | __|____| |_| | | | \ \/ /
// | |_| | ||_____|  _| | |_| |>  <
//  \__, |\__|    |_| |_|\__,_/_/\_\
//  |___/
//
// Uses Miniflux API to gather recent youtube videos, then lets
// the user select which one to download/copy/open
//
// This things a work in progress. It functions... but it's
// ugly as hell and incredibly unportable. Give it time. LET BRO COOK
//
// Tristan Lukens, 2025

import { Command, Option } from "commander";
import { MinifluxClient } from "miniflux-js";
import nfzf from "node-fzf";

import yoctoSpinner from "yocto-spinner";

import * as fs from "node:fs/promises";
import * as child_process from "node:child_process";

// ---------------

const program = new Command();

const OPTION_DEFAULTS = {
	limit: 10,
	verbose: false,
	action: "open",
	directory: `${process.env.HOME}/Movies/`,
	envFile: `${process.env.HOME}/.config/yt-flux/env.json`,
	browser: "/Applications/Brave Browser.app",
};

program
	.name("yt-flux")
	.description(
		"Tool that interacts with Miniflux RSS reader API to open, copy links to or download YouTube videos"
	)
	.option(
		"-l, --limit <limit>",
		"limit for the number of listed videos",
		OPTION_DEFAULTS.limit
	)
	.addOption(
		new Option(
			"-a, --action <action>",
			"action to perform on selected video"
		)
			.choices(["open", "download", "copy", "o", "d", "c"])
			.default(OPTION_DEFAULTS.action)
	)
	.option(
		"-d, --directory <path>",
		"directory to download videos to",
		OPTION_DEFAULTS.directory
	)
	.option(
		"-b, --browser <path>",
		"path to browser to open video in",
		OPTION_DEFAULTS.browser
	)
	.option(
		"-v, --verbose",
		"display JavaScript errors",
		OPTION_DEFAULTS.verbose
	)
	.option(
		"--env-file <path>",
		"path to environment json file",
		OPTION_DEFAULTS.envFile
	)
	.version("0.1.0");

program.parse();

const OPTIONS = program.opts();

// ---------------

const getEnv = async () => {
	try {
		const buf = await fs.readFile(OPTIONS.envFile);
		return JSON.parse(buf);
	} catch (err) {
		console.error(
			"Opening of local environment file failed. Use flag --verbose for JavaScript error"
		);
		if (OPTIONS.verbose) console.error(`\n${err}`);
		process.exit(1);
	}
};

const ENV = await getEnv();

const getId = async () => {
	if (ENV.ytId) return ENV.ytId;

	const all = await client.getCategories();
	return all.find((c) => c.title == "YouTube").id;
};

const id = await getId();

const client = new MinifluxClient({
	baseURL: ENV.baseURL,
	apiKey: ENV.key,
	authType: "api_key",
});

const spinner = yoctoSpinner({
	text: "Requesting recent entries. This might take a while...",
}).start();

const entries = (
	await client.getCategoryEntries(id, {
		limit: OPTIONS.limit,
		direction: "desc",
	})
).entries;

spinner.success("Acquired recent entries");

let list = {};
entries.forEach((e) => {
	list[`${e.author} -> ${e.title}`] = `${e.url}`;
});

// Now this is what I call hideously elegant
const videos = Object.keys(list);
const video = await (async () =>
	(
		await nfzf({ list: videos, height: 100 })
	).selected.value)();
const url = await list[video];

switch (OPTIONS.action) {
	case "o":
	case "open":
		console.log(`Selected: ${video}`);
		console.log("Opening in configured browser...");

		child_process.spawn("open", ["-a", OPTIONS.browser, url]);

		break;
	case "d":
	case "download":
		console.log(`Selected: ${video}`);
		const spinner = yoctoSpinner({
			text: "Downloading video with yt-dlp. This might take a while...",
		}).start();

		child_process
			.spawn("yt-dlp", [
				// "-q",
				// "--no-warnings",
				"-o",
				`${OPTIONS.directory}/%(title)s.%(ext)s`,
				"-f",
				"mp4",
				`${url}`,
			])
			.on("exit", () => {
				spinner.success("Download completed");
			});
		break;
	case "c":
	case "copy":
		console.log(`Selected: ${video}`);
		console.log(`Copying link (${url}) to clipboard...`);

		const proc = child_process.spawn("pbcopy");
		proc.stdin.write(`${url}`);
		proc.stdin.end();
		break;
	default:
		console.log(`Unknown action: ${OPTIONS.action}`);
}
